{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to MPEL\n\n\nMPEL (Motion Planning and Experimentation Library) is a library\nwritten in C++ for solving motion planning problems and experimenting\nwith planning algorithms. The library currently allows for planning only\nin a 2 dimensional workspace. It provides an intuitive syntax and several\ncomponents which can be used to build planning algorithms either by\n\"gluing\" the components together or from scratch. The library also\nprovides user the ability to easily visualize the results thus making\nit a great tool for use in classrooms. Browse through the\ndocumentation and tutorials to learn more about the library.\n\n\nAbout\n\n\nMPEL is being developed at the \nCenter for\nMechatronics\n at \nIIT\nKanpur\n. The project is supervised by \nDr. Bhaskar\nDasgupta\n. The source code for MPEL\nis hosted on \nGithub\n.",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-mpel",
            "text": "MPEL (Motion Planning and Experimentation Library) is a library\nwritten in C++ for solving motion planning problems and experimenting\nwith planning algorithms. The library currently allows for planning only\nin a 2 dimensional workspace. It provides an intuitive syntax and several\ncomponents which can be used to build planning algorithms either by\n\"gluing\" the components together or from scratch. The library also\nprovides user the ability to easily visualize the results thus making\nit a great tool for use in classrooms. Browse through the\ndocumentation and tutorials to learn more about the library.",
            "title": "Welcome to MPEL"
        },
        {
            "location": "/#about",
            "text": "MPEL is being developed at the  Center for\nMechatronics  at  IIT\nKanpur . The project is supervised by  Dr. Bhaskar\nDasgupta . The source code for MPEL\nis hosted on  Github .",
            "title": "About"
        },
        {
            "location": "/basics/",
            "text": "Motion Planning Primer\n\n\nThis part of the website is meant to give the reader an intuitive\nfeel for the library. It is highly recommended that the reader goes\nthrough this section before proceeding to the API reference or the\ntutorials.\n\n\nThe library has been designed so that it is possible to use\npre-built planner as well as build new planners from scratch. The\nsyntax of the library seems natural once the user is familiar with\na few concepts and terminology.\n\n\nTerminology\n\n\nPoint\n: A point is any location in the 2D workspace.\n\n\nPath\n: A path is a sequence of points.\n\n\nMap\n: A map is a bitmap representing the occupied and free regions\nin the space where the path is to be planned.\n\n\nStructure of Motion Planning Algorithms\n\n\nWe propose that most motion planning algorithms can be represented\nas a combination of four basic components:\n\n\n\n\nCollision Checker\n\n\nGraph Builder\n\n\nGraph Search\n\n\nInterpolator\n\n\n\n\nCollision Checker\n\n\nA collision checker is used in algorithms whenever they need to\ncheck if a state of the robot causes collision with the workspace\nor not. This library currently supports planning in 2D environments\ntherefore there is only a single pre-built collision checker built\ninto all the motion planners and cannot be changed.\n\n\nGraph Builder\n\n\nA graph builder is an algorithm which takes a map of the workspace as\nthe input and generates a graph which is then used by the motion\nplanner for finding paths. For an algorithm which does not require\na graph but works directly on a map, it is possible to generate a\ngraph that contains every point of the map. Some graph builders are:\n\n\n\n\nVoronoi Roadmap Builder\n\n\nProbabilistic Roadmap Builder\n\n\nVisibility Roadmap\n\n\n\n\nGraph Search\n\n\nA graph search is an algorithm which returns the path between two\nnodes in a graph. This is one of the key player in determining the\nefficiency of the planning algorithm. Some graph searches are:\n\n\n\n\nDijkstra's Search\n\n\nBreadth First Search\n\n\nA* Search\n\n\n\n\nInterpolator\n\n\nAn interpolator is the algorithm which gives the path that the robot\nfollows after processing the path from graph search. The interpolator\ncan perform smoothing, simplifications etc on the input path. An\ninterpolator can also be used to implement planners that rely only\non local information of the workspace. Planning using potential\nfields can be thought of as an interpolator which works on the straight\nline path between start and end points.",
            "title": "Basic Ideas"
        },
        {
            "location": "/basics/#motion-planning-primer",
            "text": "This part of the website is meant to give the reader an intuitive\nfeel for the library. It is highly recommended that the reader goes\nthrough this section before proceeding to the API reference or the\ntutorials.  The library has been designed so that it is possible to use\npre-built planner as well as build new planners from scratch. The\nsyntax of the library seems natural once the user is familiar with\na few concepts and terminology.",
            "title": "Motion Planning Primer"
        },
        {
            "location": "/basics/#terminology",
            "text": "Point : A point is any location in the 2D workspace.  Path : A path is a sequence of points.  Map : A map is a bitmap representing the occupied and free regions\nin the space where the path is to be planned.",
            "title": "Terminology"
        },
        {
            "location": "/basics/#structure-of-motion-planning-algorithms",
            "text": "We propose that most motion planning algorithms can be represented\nas a combination of four basic components:   Collision Checker  Graph Builder  Graph Search  Interpolator",
            "title": "Structure of Motion Planning Algorithms"
        },
        {
            "location": "/basics/#collision-checker",
            "text": "A collision checker is used in algorithms whenever they need to\ncheck if a state of the robot causes collision with the workspace\nor not. This library currently supports planning in 2D environments\ntherefore there is only a single pre-built collision checker built\ninto all the motion planners and cannot be changed.",
            "title": "Collision Checker"
        },
        {
            "location": "/basics/#graph-builder",
            "text": "A graph builder is an algorithm which takes a map of the workspace as\nthe input and generates a graph which is then used by the motion\nplanner for finding paths. For an algorithm which does not require\na graph but works directly on a map, it is possible to generate a\ngraph that contains every point of the map. Some graph builders are:   Voronoi Roadmap Builder  Probabilistic Roadmap Builder  Visibility Roadmap",
            "title": "Graph Builder"
        },
        {
            "location": "/basics/#graph-search",
            "text": "A graph search is an algorithm which returns the path between two\nnodes in a graph. This is one of the key player in determining the\nefficiency of the planning algorithm. Some graph searches are:   Dijkstra's Search  Breadth First Search  A* Search",
            "title": "Graph Search"
        },
        {
            "location": "/basics/#interpolator",
            "text": "An interpolator is the algorithm which gives the path that the robot\nfollows after processing the path from graph search. The interpolator\ncan perform smoothing, simplifications etc on the input path. An\ninterpolator can also be used to implement planners that rely only\non local information of the workspace. Planning using potential\nfields can be thought of as an interpolator which works on the straight\nline path between start and end points.",
            "title": "Interpolator"
        },
        {
            "location": "/algos/",
            "text": "Algorithms\n\n\nThis page is meant to describe the various algorithms used\nin the library.\n\n\nGraph Search\n\n\nDijkstra's Search\n\n\nBreadth First Search\n\n\nA* Search\n\n\nGraph Builder\n\n\nProbabiistic Graph Builder\n\n\nVoronoi Graph Builder\n\n\nInterpolator\n\n\nPotential Field Interpolator",
            "title": "Algorithms"
        },
        {
            "location": "/algos/#algorithms",
            "text": "This page is meant to describe the various algorithms used\nin the library.",
            "title": "Algorithms"
        },
        {
            "location": "/algos/#graph-search",
            "text": "",
            "title": "Graph Search"
        },
        {
            "location": "/algos/#dijkstras-search",
            "text": "",
            "title": "Dijkstra's Search"
        },
        {
            "location": "/algos/#breadth-first-search",
            "text": "",
            "title": "Breadth First Search"
        },
        {
            "location": "/algos/#a42-search",
            "text": "",
            "title": "A* Search"
        },
        {
            "location": "/algos/#graph-builder",
            "text": "",
            "title": "Graph Builder"
        },
        {
            "location": "/algos/#probabiistic-graph-builder",
            "text": "",
            "title": "Probabiistic Graph Builder"
        },
        {
            "location": "/algos/#voronoi-graph-builder",
            "text": "",
            "title": "Voronoi Graph Builder"
        },
        {
            "location": "/algos/#interpolator",
            "text": "",
            "title": "Interpolator"
        },
        {
            "location": "/algos/#potential-field-interpolator",
            "text": "",
            "title": "Potential Field Interpolator"
        },
        {
            "location": "/start/",
            "text": "Getting Started\n\n\nObtaining the Library\n\n\nMPEL depends on boost and OpenCV for some of its functionality\nyou need to install these libraries before you can compile\nMPEL. They can be installed using the following commands\n\n\nsudo apt-get install libboost-all-dev\nsudo apt-get install libopencv-dev\n\n\n\n\nThe source code for the library can be downloaded from\n\nGitHub\n\n\ngit clone https://github.com/lakshayg/mpel\nmkdir mpel/build\ncd mpel/build\ncmake .. && make\n\n\n\n\nYour First Code (The Easy Way)\n\n\nThe easiest way to compile your first program is to use the\n\nuser\n directory in the repository. The \nCMakeLists.txt\n file\nin the directory takes care of linking the code.\n\n\ncd mpel/user\n# write your first code\ncd ../build\ncmake .. && make\ncd user  # your executable should be present here",
            "title": "Getting Started"
        },
        {
            "location": "/start/#getting-started",
            "text": "",
            "title": "Getting Started"
        },
        {
            "location": "/start/#obtaining-the-library",
            "text": "MPEL depends on boost and OpenCV for some of its functionality\nyou need to install these libraries before you can compile\nMPEL. They can be installed using the following commands  sudo apt-get install libboost-all-dev\nsudo apt-get install libopencv-dev  The source code for the library can be downloaded from GitHub  git clone https://github.com/lakshayg/mpel\nmkdir mpel/build\ncd mpel/build\ncmake .. && make",
            "title": "Obtaining the Library"
        },
        {
            "location": "/start/#your-first-code-the-easy-way",
            "text": "The easiest way to compile your first program is to use the user  directory in the repository. The  CMakeLists.txt  file\nin the directory takes care of linking the code.  cd mpel/user\n# write your first code\ncd ../build\ncmake .. && make\ncd user  # your executable should be present here",
            "title": "Your First Code (The Easy Way)"
        },
        {
            "location": "/doc/",
            "text": "API Reference\n\n\nThis section gives a detailed description of the API. It is strongly\nsuggested that you go through the \nPrimer\n before\nreading the API Reference. If you are looking for tutorials, they\nare available \nhere\n.\n\n\nMPEL utilizes \nOpenCV\n for a lot a operations in\nthe background. Several datatypes are borrowed directly from OpenCV.\nIn such cases the code provided if merely a representation of the\nactual implementation.\n\n\nmpel/core.hpp\n\n\nThis header contains everything which is required for implementing\none's own planning algorithm. The header is further divided into\nrelated sections\n\n\nDatatypes\n\n\nPoint\n\n\nstruct Point {\n    int x, y;  // NOTE: Only integer coordinates are allowed\n    Point();\n    Point(int X, int Y) : x(X), y(Y) {}\n};\ntypedef const Point& PointRef;\n\n\n\n\nThe \nPoint\n class supports several operations like addition,\nsubtraction and multiplication with scalar.\n\n\nSegment\n\n\nstruct Segment {\n    Point p0, p1;\n    Segment(PointRef a, PointRef b) : p0(a), p1(b) {}\n};\ntypedef const Segment& SegmentRef;\n\n\n\n\nThe \nSegment\n datatype is a struct containing two points.\n\n\nPath\n\n\ntypedef std::vector<Point> Path;\ntypedef const Path& PathRef;\n\n\n\n\nThe \nPath\n datatype is implemented as a vector of points and therefore\nsupports all the operations allowed on a \nstd::vector\n.\n\n\nMap\n\n\ntypedef cv::Mat Map;\ntypedef const Map& MapRef;\n\n\n\n\nA \nMap\n is a 2D matrix which represents the workspace as an occupancy\ngrid. Map supports the \nclone()\n operation which is required whenever\na Map needs to be copied.\n\n\nGraph\n\n\nclass Graph {\npublic:\n    typedef size_t vertex_t;\n\n    Graph();\n    ~Graph();\n    void add_edge(Point pt1, Point pt2, double weight = 0);\n    size_t descriptor(PointRef pt) const;\n    size_t num_vertices() const;\n    Point vertex(size_t descriptor) const;\n    double weight(PointRef a, PointRef b) const;\n    double weight(size_t a, size_t b) const;\n    const std::vector<Point>& vertex_list() const;\nprivate:\n    ...\n};\ntypedef const Graph& GraphRef;\n\n\n\n\nThe current implementation of \nGraph\n is an \nincidence matrix\n. It\nsupports the following operations:\n\n\n\n\nadd_edge(Point pt1, Point pt2, double weight = 0)\n - Add a new edge\nin the graph. Two nodes can have only a single edge between them. A\nnegative weight indicates that no edge is present.\n\n\nsize_t descriptor(PointRef pt) const\n - Every vertex is assigned a\ndescriptor in the graph. This function returns the vertex descriptor.\n\n\nsize_t num_vertices() const\n - Returns the number of vertices in the graph.\n\n\nPoint vertex(size_t descriptor) const\n - Returns the vertex (Point)\ncorresponding to the descriptor given as input\n\n\ndouble weight(PointRef a, PointRef b) const\n - Returns the weight of\nedge given two vertices. A negative weight indicates that the verties\nare not connected.\n\n\ndouble weight(size_t a, size_t b) const\n - Returns the weight of edge\ngiven two vertex descriptors.\n\n\nconst std::vector<Point>& vertex_list() const\n - Returns the list of\nvertices present in the graph.\n\n\n\n\nWorkspace\n\n\nstruct Workspace {\n    Map map;\n};\n\n\n\n\nProblemDefinition\n\n\nstruct ProblemDefinition {\n    Point start;\n    Point goal;\n};\n\n\n\n\nThis datatype is used to specify the planning problem and pass it to\nthe motion planner.\n\n\nUtility Functions\n\n\nMotion Planner\n\n\nVisualization\n\n\nmpel/builtins.hpp\n\n\nThis header file contains definitions of all the pre-built components\nprovided with the library. The section is divided into related sections.\n\n\nGraph Builders\n\n\nGraph Searches\n\n\nInterpolators\n\n\nPlanner Configs",
            "title": "API Reference"
        },
        {
            "location": "/doc/#api-reference",
            "text": "This section gives a detailed description of the API. It is strongly\nsuggested that you go through the  Primer  before\nreading the API Reference. If you are looking for tutorials, they\nare available  here .  MPEL utilizes  OpenCV  for a lot a operations in\nthe background. Several datatypes are borrowed directly from OpenCV.\nIn such cases the code provided if merely a representation of the\nactual implementation.",
            "title": "API Reference"
        },
        {
            "location": "/doc/#mpelcorehpp",
            "text": "This header contains everything which is required for implementing\none's own planning algorithm. The header is further divided into\nrelated sections",
            "title": "mpel/core.hpp"
        },
        {
            "location": "/doc/#datatypes",
            "text": "",
            "title": "Datatypes"
        },
        {
            "location": "/doc/#point",
            "text": "struct Point {\n    int x, y;  // NOTE: Only integer coordinates are allowed\n    Point();\n    Point(int X, int Y) : x(X), y(Y) {}\n};\ntypedef const Point& PointRef;  The  Point  class supports several operations like addition,\nsubtraction and multiplication with scalar.",
            "title": "Point"
        },
        {
            "location": "/doc/#segment",
            "text": "struct Segment {\n    Point p0, p1;\n    Segment(PointRef a, PointRef b) : p0(a), p1(b) {}\n};\ntypedef const Segment& SegmentRef;  The  Segment  datatype is a struct containing two points.",
            "title": "Segment"
        },
        {
            "location": "/doc/#path",
            "text": "typedef std::vector<Point> Path;\ntypedef const Path& PathRef;  The  Path  datatype is implemented as a vector of points and therefore\nsupports all the operations allowed on a  std::vector .",
            "title": "Path"
        },
        {
            "location": "/doc/#map",
            "text": "typedef cv::Mat Map;\ntypedef const Map& MapRef;  A  Map  is a 2D matrix which represents the workspace as an occupancy\ngrid. Map supports the  clone()  operation which is required whenever\na Map needs to be copied.",
            "title": "Map"
        },
        {
            "location": "/doc/#graph",
            "text": "class Graph {\npublic:\n    typedef size_t vertex_t;\n\n    Graph();\n    ~Graph();\n    void add_edge(Point pt1, Point pt2, double weight = 0);\n    size_t descriptor(PointRef pt) const;\n    size_t num_vertices() const;\n    Point vertex(size_t descriptor) const;\n    double weight(PointRef a, PointRef b) const;\n    double weight(size_t a, size_t b) const;\n    const std::vector<Point>& vertex_list() const;\nprivate:\n    ...\n};\ntypedef const Graph& GraphRef;  The current implementation of  Graph  is an  incidence matrix . It\nsupports the following operations:   add_edge(Point pt1, Point pt2, double weight = 0)  - Add a new edge\nin the graph. Two nodes can have only a single edge between them. A\nnegative weight indicates that no edge is present.  size_t descriptor(PointRef pt) const  - Every vertex is assigned a\ndescriptor in the graph. This function returns the vertex descriptor.  size_t num_vertices() const  - Returns the number of vertices in the graph.  Point vertex(size_t descriptor) const  - Returns the vertex (Point)\ncorresponding to the descriptor given as input  double weight(PointRef a, PointRef b) const  - Returns the weight of\nedge given two vertices. A negative weight indicates that the verties\nare not connected.  double weight(size_t a, size_t b) const  - Returns the weight of edge\ngiven two vertex descriptors.  const std::vector<Point>& vertex_list() const  - Returns the list of\nvertices present in the graph.",
            "title": "Graph"
        },
        {
            "location": "/doc/#workspace",
            "text": "struct Workspace {\n    Map map;\n};",
            "title": "Workspace"
        },
        {
            "location": "/doc/#problemdefinition",
            "text": "struct ProblemDefinition {\n    Point start;\n    Point goal;\n};  This datatype is used to specify the planning problem and pass it to\nthe motion planner.",
            "title": "ProblemDefinition"
        },
        {
            "location": "/doc/#utility-functions",
            "text": "",
            "title": "Utility Functions"
        },
        {
            "location": "/doc/#motion-planner",
            "text": "",
            "title": "Motion Planner"
        },
        {
            "location": "/doc/#visualization",
            "text": "",
            "title": "Visualization"
        },
        {
            "location": "/doc/#mpelbuiltinshpp",
            "text": "This header file contains definitions of all the pre-built components\nprovided with the library. The section is divided into related sections.",
            "title": "mpel/builtins.hpp"
        },
        {
            "location": "/doc/#graph-builders",
            "text": "",
            "title": "Graph Builders"
        },
        {
            "location": "/doc/#graph-searches",
            "text": "",
            "title": "Graph Searches"
        },
        {
            "location": "/doc/#interpolators",
            "text": "",
            "title": "Interpolators"
        },
        {
            "location": "/doc/#planner-configs",
            "text": "",
            "title": "Planner Configs"
        },
        {
            "location": "/tut/",
            "text": "MPEL Tutorials\n\n\nUsing a pre-built planner\n\n\nThe code below shows how to use a motion planner provided by the library\nfor motion planning\n\n\n#include <mpel/core.hpp>\n#include <mpel/builtins.hpp>\n\nusing namespace mpel;\n\nint main() {\n    Planner::Config pc = voronoi_planner_config();  // Pre-built planner configuration\n    Planner p(pc); // Define a voronoi roadmap planner\n\n    Workspace ws;\n    ws.map = load_map_from_image(\"004.bmp\"); // load the workspace map from a bitmap\n                                             // this is currently the ONLY method for\n                                             // loading maps\n\n    ProblemDefinition pdef;      // Definition of the problem to be solved\n    pdef.start = Point(50,50);\n    pdef.goal = Point(400,400);\n\n    p.load_workspace(ws);        // load workspace into the planner\n    Path path = p.solve(pdef);   // solve the given problem and give the path as output\n\n    View v(\"Voronoi Planner\");   // Display the results\n    v.add_layer(p);\n    v.add_layer(path);\n    View::stay(); // Prevent the program from exiting\n\n    return 0;\n}",
            "title": "Tutorials"
        },
        {
            "location": "/tut/#mpel-tutorials",
            "text": "",
            "title": "MPEL Tutorials"
        },
        {
            "location": "/tut/#using-a-pre-built-planner",
            "text": "The code below shows how to use a motion planner provided by the library\nfor motion planning  #include <mpel/core.hpp>\n#include <mpel/builtins.hpp>\n\nusing namespace mpel;\n\nint main() {\n    Planner::Config pc = voronoi_planner_config();  // Pre-built planner configuration\n    Planner p(pc); // Define a voronoi roadmap planner\n\n    Workspace ws;\n    ws.map = load_map_from_image(\"004.bmp\"); // load the workspace map from a bitmap\n                                             // this is currently the ONLY method for\n                                             // loading maps\n\n    ProblemDefinition pdef;      // Definition of the problem to be solved\n    pdef.start = Point(50,50);\n    pdef.goal = Point(400,400);\n\n    p.load_workspace(ws);        // load workspace into the planner\n    Path path = p.solve(pdef);   // solve the given problem and give the path as output\n\n    View v(\"Voronoi Planner\");   // Display the results\n    v.add_layer(p);\n    v.add_layer(path);\n    View::stay(); // Prevent the program from exiting\n\n    return 0;\n}",
            "title": "Using a pre-built planner"
        },
        {
            "location": "/trouble/",
            "text": "Troubleshooting",
            "title": "Troubleshooting"
        },
        {
            "location": "/trouble/#troubleshooting",
            "text": "",
            "title": "Troubleshooting"
        },
        {
            "location": "/contact/",
            "text": "Contact\n\n\nThe library is still in the early stages of development and may be\nmissing features and containing bugs. We would appreciate any\nfeedback or feature request or bug report. Contributions in form of\ncode are welcome.\n\n\nYou can reach out to us at \nlakshayg@iitk.ac.in",
            "title": "Contact Us"
        },
        {
            "location": "/contact/#contact",
            "text": "The library is still in the early stages of development and may be\nmissing features and containing bugs. We would appreciate any\nfeedback or feature request or bug report. Contributions in form of\ncode are welcome.  You can reach out to us at  lakshayg@iitk.ac.in",
            "title": "Contact"
        }
    ]
}